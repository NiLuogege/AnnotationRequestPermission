/*
 * Created by 动脑科技-Tim on 17-6-19 上午11:23
 * Copyright (c) 2017. All rights reserved
 *
 * Last modified 17-6-19 上午11:23
 */

package com.example

import com.squareup.kotlinpoet.*
import javax.lang.model.element.TypeElement
import com.squareup.kotlinpoet.TypeName.Companion.asTypeName
import java.util.*
import java.util.concurrent.atomic.AtomicInteger
import javax.tools.StandardLocation

class ClassBuilder(val typeElement:TypeElement, val methodElement: List<NeedMethod>) {

    companion object {
        //不需要计算的常量
        const val CALLER = "target"
        const val REQUEST = "requestCode"
        const val RESULT = "grantResults"
    }

    //包名
    val PACKAGE_NAME = ELEMENT_UTILS.getPackageOf(typeElement).qualifiedName.toString()
    //类的全类名
    val FULL_NAME = typeElement.qualifiedName.toString()
    //类名
    val CLASS_NAME by lazy {
        var name = FULL_NAME.substring(PACKAGE_NAME.length + 1)
        val index = name.indexOf(".")
        if (index > 0) {
            name = name.substring(index+1, name.length)
        }
        name
    }

    //获得当前类的Type
    val TYPE_TARGET = ELEMENT_UTILS.getTypeElement(FULL_NAME).asType()
    //当前类的ClassNme
    val TARGET = TYPE_TARGET.asTypeName()

    // 判断当前类是否问actvity等的子类
    val isActivity = TYPE_UTILS.isSubtype(TYPE_TARGET, TYPE_ACTIVITY)
    val isFragment = TYPE_UTILS.isSubtype(TYPE_TARGET, TYPE_FRAGMENT)
    val isSupportFragment = if (null == TYPE_SUPPORT) false else TYPE_UTILS.isSubtype(TYPE_TARGET, TYPE_SUPPORT)

    //请求码
    val currentCode = AtomicInteger(100000)

    //标有onDenieds 的元素
    val onDenieds = typeElement.getChildWithAnnotaion(OnDeined::class.java)
    //不再提示
    val onNeverAsk = typeElement.getChildWithAnnotaion(OnNeverAsk::class.java)

    fun brewKotlin() {
        val className = "${CLASS_NAME}Permission"

        val typeSpec = TypeSpec.objectBuilder(className)

        //调用checkSelfPermission的成员名
        var checkCaller = CALLER

        when {
            /*
            * 如果是Fragment或者activity添加target就可以了
            * 调用checkSelfPermission 需要从Fragment获得Activity
            * 调用requestPermissions shouldShowRequestPermissionRationale 可以使用Fragment
            * */
            isSupportFragment || isFragment || isActivity -> {
                if (!isActivity)
                    checkCaller = "$CALLER.activity"
            }
            else -> {
                throw Exception("checkSelfPermission should only call by Activity or Fragment")
            }
        }
        //请求结果回调方法
        val requestResult = FunSpec.builder("onRequestPermissionsResult")
                .addParameter(CALLER,TARGET)
                .addParameter(REQUEST, Int::class)
                .addParameter(RESULT, IntArray::class)
                .addKdoc("Please call this method in $CLASS_NAME#onRequestPermissionsResult")

        val resultBlock = CodeBlock.builder()
                .beginControlFlow("when($REQUEST)")
        methodElement.forEach {
            need ->
            //target中对应的方法
            val invokeOriginal = "$CALLER.${need.methodName}()"
            //添加属性：权限的字符串数组与权限请求码
            val (propertyPermission, propertyRequest) = addProperties(need, typeSpec)
            addPermissionMethod(need, typeSpec, propertyPermission, propertyRequest, checkCaller, invokeOriginal)
            addRequestResult(need, resultBlock, propertyPermission, propertyRequest, invokeOriginal)
        }
        resultBlock.endControlFlow()
        typeSpec.addFun(requestResult.addCode(resultBlock.build()).build())

        println("xxxx$className")
        FILER_UTILS.createResource(StandardLocation.SOURCE_OUTPUT, PACKAGE_NAME, "$className.kt")
                .openWriter()
                .use {
                    with(KotlinFile.builder(PACKAGE_NAME, className)) {
                        addType(typeSpec.build())
                        addFileComment("generated by Kapt, Do not modify!")
                        build()
                    }.writeTo(it)
                }
    }

    fun addProperties(need: NeedMethod, typeSpec: TypeSpec.Builder):Array<String> {
        //创建属性 值为方法需要权限的数组
        val propertyPermission = "PERMISSION_${need.methodName.toUpperCase()}"
        //值为方法 请求码
        val propertyRequest = "REQUEST_${need.methodName.toUpperCase()}"
        val permissionStr = need.permissionName.joinToString ("\",\"")

        typeSpec.addProperties(
           listOf(PropertySpec
                   .builder(propertyPermission, STRINGARRAY,KModifier.PRIVATE)
                   .initializer("arrayOf(\"$permissionStr\")")
                   .addKdoc("from $CLASS_NAME#${need.methodName}")
                   .build(),
                   PropertySpec
                   .builder(propertyRequest, Int::class, KModifier.PRIVATE)
                   .addKdoc("request $CLASS_NAME#${need.methodName} needs permission")
                   .initializer("${currentCode.getAndIncrement()}")
                   .build()))
        return arrayOf(propertyPermission, propertyRequest)
    }

    //调用此方法来替代被NeedPermission注解的方法
    fun addPermissionMethod(need:NeedMethod, typeSpec: TypeSpec.Builder, propertyPermission:String,
                            propertyRequest:String, checkCaller:String, invokeOriginal:String) {

        val builder = FunSpec.builder("${need.methodName}").run {
            addParameter(CALLER,TARGET)
            //加入权限判断代码
            addCode(CodeBlock.builder()
                    //需要使用%T转椅，这样才会自动导包
                    //是否大于23api
                    .beginControlFlow( " if (%T.VERSION.SDK_INT >= %T.VERSION_CODES.M)", BUILD, BUILD)
                    //未获取权限列表
                    .addStatement("val list = $propertyPermission.filter {$checkCaller.checkSelfPermission(it) == %T.PERMISSION_DENIED}", PACKAGEMANAGER)
                    //如果没有获得权限
                    .beginControlFlow("if(list.isEmpty())")
                    .addStatement(invokeOriginal)
                    .nextControlFlow("else")
                    //请求权限
                    .addStatement("$CALLER.requestPermissions(list.toTypedArray(),$propertyRequest)")
                    .endControlFlow()
                    .nextControlFlow("else")
                    .addStatement(invokeOriginal)
                    .endControlFlow()
                    .build())
                addKdoc("Please call this method replace $CLASS_NAME#${need.methodName}")
        }
        typeSpec.addFun(builder.build())
    }

    fun addRequestResult(need:NeedMethod, resultBlock: CodeBlock.Builder, propertyPermission: String,
                         propertyRequest: String, invokeOriginal: String) {

        val onDenied = findOnDenied(need)
        val onNeverAsk = findOnNeverAsk(need)

        resultBlock.beginControlFlow("$propertyRequest -> ")
        resultBlock.beginControlFlow("if($RESULT.all { it == PackageManager.PERMISSION_GRANTED})")
        resultBlock.addStatement(invokeOriginal)
        resultBlock.nextControlFlow("else")
        resultBlock.beginControlFlow("if ($propertyPermission.all {$CALLER.shouldShowRequestPermissionRationale(it)})")
        //TODO 这里调用请求失败
        if (onDenied != null) {
            resultBlock.addStatement("$CALLER.${onDenied.simpleName()}()")
        }
        resultBlock.nextControlFlow("else")
        //TODO 这里调用永远不显示
        if (onNeverAsk != null)
            resultBlock.addStatement("$CALLER.${onNeverAsk.simpleName()}()")
        resultBlock.endControlFlow()
        resultBlock.endControlFlow()
        resultBlock.endControlFlow()
    }

}

//fun main(args: Array<String>) {
//    println(Arrays.equals(arrayOf("1","2"), arrayOf("2","1")))
//}